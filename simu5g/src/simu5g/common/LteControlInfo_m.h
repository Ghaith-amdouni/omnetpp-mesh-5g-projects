//
// Generated file, do not edit! Created by opp_msgtool 6.3 from simu5g/common/LteControlInfo.msg.
//

#ifndef __SIMU5G_LTECONTROLINFO_M_H
#define __SIMU5G_LTECONTROLINFO_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0603
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif


namespace simu5g {

class LteControlInfo;
class FlowControlInfo;
class UserControlInfo;

}  // namespace simu5g

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/TagBase_m.h" // import inet.common.TagBase

#include "inet/common/geometry/Geometry_m.h" // import inet.common.geometry.Geometry

#include "inet/common/Units_m.h" // import inet.common.Units

#include "simu5g/common/LteCommon_m.h" // import simu5g.common.LteCommon

#include "simu5g/stack/mac/amc/UserTxParams_m.h" // import simu5g.stack.mac.amc.UserTxParams


namespace simu5g {

/**
 * Class generated from <tt>simu5g/common/LteControlInfo.msg:55</tt> by opp_msgtool.
 * <pre>
 * //
 * // \@class LteControlInfo
 * // \@brief Base class for FlowControlInfo and UserControlInfo
 * //
 * // This class contains information present in both Flow and User ControlInfo:
 * // - Source MAC Node ID
 * // - Destination MAC Node ID
 * //
 * class LteControlInfo extends inet::TagBase
 * {
 *     MacNodeId sourceId = NODEID_NONE;                    // Source MacNodeId
 *     MacNodeId destId = NODEID_NONE;                      // Destination MacNodeId
 *     unsigned short direction \@enum(Direction);            // Traffic Direction (UL, DL, D2D)
 *     MacNodeId d2dTxPeerId = NODEID_NONE;
 *     MacNodeId d2dRxPeerId = NODEID_NONE;
 * 
 *     //# Traffic Control Information
 * 
 *     unsigned short application \@enum(ApplicationType) = 0;    // Application Type
 *     unsigned short traffic \@enum(LteTrafficClass) = 0;        // Lte Traffic Type
 * 
 *     //# RLC Control Information
 * 
 *     unsigned short rlcType \@enum(LteRlcType) = 0;            // RLC Traffic Type
 * 
 *     //# Connection Information
 * 
 *     uint16 lcid = 0;                                        // Logical Connection Identifier
 *     int32 multicastGroupId = -1;                        // Identifier for a multicast group (it is in range [0:[2^28)-1] )
 *                                                         // For unicast communications, this field is -1
 * }
 * </pre>
 */
class LteControlInfo : public ::inet::TagBase
{
  protected:
    MacNodeId sourceId = NODEID_NONE;
    MacNodeId destId = NODEID_NONE;
    unsigned short direction = 0;
    MacNodeId d2dTxPeerId = NODEID_NONE;
    MacNodeId d2dRxPeerId = NODEID_NONE;
    unsigned short application = 0;
    unsigned short traffic = 0;
    unsigned short rlcType = 0;
    uint16_t lcid = 0;
    int32_t multicastGroupId = -1;

  private:
    void copy(const LteControlInfo& other);

  protected:
    bool operator==(const LteControlInfo&) = delete;

  public:
    LteControlInfo();
    LteControlInfo(const LteControlInfo& other);
    virtual ~LteControlInfo();
    LteControlInfo& operator=(const LteControlInfo& other);
    virtual LteControlInfo *dup() const override {return new LteControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual MacNodeId getSourceId() const;
    virtual void setSourceId(MacNodeId sourceId);

    virtual MacNodeId getDestId() const;
    virtual void setDestId(MacNodeId destId);

    virtual unsigned short getDirection() const;
    virtual void setDirection(unsigned short direction);

    virtual MacNodeId getD2dTxPeerId() const;
    virtual void setD2dTxPeerId(MacNodeId d2dTxPeerId);

    virtual MacNodeId getD2dRxPeerId() const;
    virtual void setD2dRxPeerId(MacNodeId d2dRxPeerId);

    virtual unsigned short getApplication() const;
    virtual void setApplication(unsigned short application);

    virtual unsigned short getTraffic() const;
    virtual void setTraffic(unsigned short traffic);

    virtual unsigned short getRlcType() const;
    virtual void setRlcType(unsigned short rlcType);

    virtual uint16_t getLcid() const;
    virtual void setLcid(uint16_t lcid);

    virtual int32_t getMulticastGroupId() const;
    virtual void setMulticastGroupId(int32_t multicastGroupId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LteControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LteControlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simu5g/common/LteControlInfo.msg:91</tt> by opp_msgtool.
 * <pre>
 * //
 * // \@class FlowControlInfo
 * // \@brief contains information flowing from LteIp to Mac
 * //
 * // It contains the following information:
 * // - IP Control Informations: the four tuple, a sequence number and
 * //   the header size (IP + Transport) to be used by pdcp ROHC.
 * // - Traffic Control Informations: Application, Direction, Traffic
 * // - RLC Control Informations: the traffic type (TM, UM, AM)
 * // - Connection information: Logical CID
 * //
 * class FlowControlInfo extends LteControlInfo
 * {
 *     uint32 srcAddr = 0;                     // source IP
 *     uint32 dstAddr = 0;                     // destination IP
 *     uint16 typeOfService = 0;               // IP Type Of Service
 *     unsigned int sequenceNumber = 0;        // packet sequence number
 *     int headerSize = 0;                     // IP + Transport header size (used by pdcp ROHC)
 *     bool useNR = false;                     // flag for sending this packet using NR
 * }
 * </pre>
 */
class FlowControlInfo : public ::simu5g::LteControlInfo
{
  protected:
    uint32_t srcAddr = 0;
    uint32_t dstAddr = 0;
    uint16_t typeOfService = 0;
    unsigned int sequenceNumber = 0;
    int headerSize = 0;
    bool useNR = false;

  private:
    void copy(const FlowControlInfo& other);

  protected:
    bool operator==(const FlowControlInfo&) = delete;

  public:
    FlowControlInfo();
    FlowControlInfo(const FlowControlInfo& other);
    virtual ~FlowControlInfo();
    FlowControlInfo& operator=(const FlowControlInfo& other);
    virtual FlowControlInfo *dup() const override {return new FlowControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getSrcAddr() const;
    virtual void setSrcAddr(uint32_t srcAddr);

    virtual uint32_t getDstAddr() const;
    virtual void setDstAddr(uint32_t dstAddr);

    virtual uint16_t getTypeOfService() const;
    virtual void setTypeOfService(uint16_t typeOfService);

    virtual unsigned int getSequenceNumber() const;
    virtual void setSequenceNumber(unsigned int sequenceNumber);

    virtual int getHeaderSize() const;
    virtual void setHeaderSize(int headerSize);

    virtual bool getUseNR() const;
    virtual void setUseNR(bool useNR);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FlowControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FlowControlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simu5g/common/LteControlInfo.msg:111</tt> by opp_msgtool.
 * <pre>
 * //
 * // \@class UserControlInfo
 * // \@brief contains information flowing from Mac to Phy
 * //
 * // It contains the following information:
 * // - H-ARQ Control Information
 * // - PHY Control Informations: Broadcast, Corruption, Type,
 * //   txMode, Resource blocks used, RemoteSet
 * //
 * class UserControlInfo extends LteControlInfo
 * {
 *     bool isNr = false;
 *     inet::GHz carrierFrequency;       // carrier frequency
 * 
 *     //# H-ARQ Control Information
 * 
 *     unsigned char acid = 0;              // H-ARQ process identifier
 *     unsigned char cw = 0;                // H-ARQ codeword identifier
 *     unsigned char txNumber = 0;          // number of (re)transmissions for the same pdu (1, 2, 3, 4)
 *     bool ndi = true;                     // new data indicator (new data overwrites a process content if present)
 * 
 *     //# PHY Control Informations
 * 
 *     bool isCorruptible = false;                         // Frame is corruptible
 *     bool isBroadcast = false;                           // Broadcast packet
 *     bool deciderResult = false;                         // Decider result
 *     double blerTh = NaN;                                // Calculated BLER threshold for this transmission
 *     double blerValue = NaN;                             // Extracted BLER for this transmission (blerValue > blerTh ==> corrupted)
 *     unsigned short txMode \@enum(TxMode) = 0;             // Traffic Type
 *     unsigned int frameType \@enum(LtePhyFrameType) = 0;   // Frame Type
 *     double txPower = NaN;                               //Transmission Power
 *     double d2dTxPower = NaN;                            // D2D Transmission Power (used for feedback reporting of D2D links
 *     // blocks granted on all Remotes, all Bands
 *     unsigned int totalGrantedBlocks = 0;
 *     unsigned int grantId = 0;                           // grantId related to the grand that allowed the sending of a MEC PDU (used only for MAC PDU sent by UEs)
 * 
 *     UserTxParams *userTxParams \@owned;
 *     RbMap grantedBlocks;
 *     inet::Coord coord;                                  // The playground position of the sending host
 *     FeedbackRequest feedbackReq;
 * }
 * </pre>
 */
class UserControlInfo : public ::simu5g::LteControlInfo
{
  protected:
    bool isNr_ = false;
    ::inet::GHz carrierFrequency = inet::GHz(NaN);
    unsigned char acid = 0;
    unsigned char cw = 0;
    unsigned char txNumber = 0;
    bool ndi = true;
    bool isCorruptible_ = false;
    bool isBroadcast_ = false;
    bool deciderResult = false;
    double blerTh = NaN;
    double blerValue = NaN;
    unsigned short txMode = 0;
    unsigned int frameType = 0;
    double txPower = NaN;
    double d2dTxPower = NaN;
    unsigned int totalGrantedBlocks = 0;
    unsigned int grantId = 0;
    UserTxParams * userTxParams = nullptr;
    RbMap grantedBlocks;
    ::inet::Coord coord;
    FeedbackRequest feedbackReq;

  private:
    void copy(const UserControlInfo& other);

  protected:
    bool operator==(const UserControlInfo&) = delete;

  public:
    UserControlInfo();
    UserControlInfo(const UserControlInfo& other);
    virtual ~UserControlInfo();
    UserControlInfo& operator=(const UserControlInfo& other);
    virtual UserControlInfo *dup() const override {return new UserControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool isNr() const;
    virtual void setIsNr(bool isNr);

    virtual ::inet::GHz getCarrierFrequency() const;
    virtual void setCarrierFrequency(::inet::GHz carrierFrequency);

    virtual unsigned char getAcid() const;
    virtual void setAcid(unsigned char acid);

    virtual unsigned char getCw() const;
    virtual void setCw(unsigned char cw);

    virtual unsigned char getTxNumber() const;
    virtual void setTxNumber(unsigned char txNumber);

    virtual bool getNdi() const;
    virtual void setNdi(bool ndi);

    virtual bool isCorruptible() const;
    virtual void setIsCorruptible(bool isCorruptible);

    virtual bool isBroadcast() const;
    virtual void setIsBroadcast(bool isBroadcast);

    virtual bool getDeciderResult() const;
    virtual void setDeciderResult(bool deciderResult);

    virtual double getBlerTh() const;
    virtual void setBlerTh(double blerTh);

    virtual double getBlerValue() const;
    virtual void setBlerValue(double blerValue);

    virtual unsigned short getTxMode() const;
    virtual void setTxMode(unsigned short txMode);

    virtual unsigned int getFrameType() const;
    virtual void setFrameType(unsigned int frameType);

    virtual double getTxPower() const;
    virtual void setTxPower(double txPower);

    virtual double getD2dTxPower() const;
    virtual void setD2dTxPower(double d2dTxPower);

    virtual unsigned int getTotalGrantedBlocks() const;
    virtual void setTotalGrantedBlocks(unsigned int totalGrantedBlocks);

    virtual unsigned int getGrantId() const;
    virtual void setGrantId(unsigned int grantId);

    virtual const UserTxParams * getUserTxParams() const;
    virtual UserTxParams * getUserTxParamsForUpdate() { return const_cast<UserTxParams *>(const_cast<UserControlInfo*>(this)->getUserTxParams());}
    virtual void setUserTxParams(UserTxParams * userTxParams);
    virtual UserTxParams * removeUserTxParams();
    [[deprecated]] UserTxParams * dropUserTxParams() {return removeUserTxParams();}

    virtual const RbMap& getGrantedBlocks() const;
    virtual RbMap& getGrantedBlocksForUpdate() { return const_cast<RbMap&>(const_cast<UserControlInfo*>(this)->getGrantedBlocks());}
    virtual void setGrantedBlocks(const RbMap& grantedBlocks);

    virtual const ::inet::Coord& getCoord() const;
    virtual ::inet::Coord& getCoordForUpdate() { return const_cast<::inet::Coord&>(const_cast<UserControlInfo*>(this)->getCoord());}
    virtual void setCoord(const ::inet::Coord& coord);

    virtual const FeedbackRequest& getFeedbackReq() const;
    virtual FeedbackRequest& getFeedbackReqForUpdate() { return const_cast<FeedbackRequest&>(const_cast<UserControlInfo*>(this)->getFeedbackReq());}
    virtual void setFeedbackReq(const FeedbackRequest& feedbackReq);


    virtual const unsigned int getBlocks(Remote antenna, Band b) const { return grantedBlocks.at(antenna).at(b); }
    virtual void setBlocks(Remote antenna, Band b, const unsigned int blocks) { grantedBlocks[antenna][b] = blocks; }
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UserControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UserControlInfo& obj) {obj.parsimUnpack(b);}


}  // namespace simu5g


namespace omnetpp {

inline any_ptr toAnyPtr(const simu5g::RbMap *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline simu5g::RbMap *fromAnyPtr(any_ptr ptr) { return ptr.get<simu5g::RbMap>(); }
template<> inline simu5g::LteControlInfo *fromAnyPtr(any_ptr ptr) { return check_and_cast<simu5g::LteControlInfo*>(ptr.get<cObject>()); }
template<> inline simu5g::FlowControlInfo *fromAnyPtr(any_ptr ptr) { return check_and_cast<simu5g::FlowControlInfo*>(ptr.get<cObject>()); }
template<> inline simu5g::UserControlInfo *fromAnyPtr(any_ptr ptr) { return check_and_cast<simu5g::UserControlInfo*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __SIMU5G_LTECONTROLINFO_M_H

