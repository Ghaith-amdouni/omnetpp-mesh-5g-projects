//
// Generated file, do not edit! Created by opp_msgtool 6.3 from simu5g/common/LteCommon.msg.
//

#ifndef __SIMU5G_LTECOMMON_M_H
#define __SIMU5G_LTECOMMON_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0603
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif


namespace simu5g {

struct RemoteUnitPhyData;
struct FeedbackRequest;

}  // namespace simu5g


namespace inet {


}  // namespace inet

#include "inet/common/geometry/Geometry_m.h" // import inet.common.geometry.Geometry

#include "simu5g/common/LteCommonEnum_m.h" // import simu5g.common.LteCommonEnum


namespace simu5g {

// cplusplus {{
using namespace omnetpp;

/// MAC node ID
enum class MacNodeId : unsigned short {};  // emulate "strong typedef" with enum class

// Facilitates finding places where the numeric value of MacNodeId is used
inline unsigned short num(MacNodeId id) { return static_cast<unsigned short>(id); }

inline std::ostream& operator<<(std::ostream& os, MacNodeId id) { os << static_cast<unsigned short>(id); return os; }

// The following operators are mostly for simplifying comparisons and transformations involving UE_MIN_ID and similar constants
inline bool operator<(MacNodeId a, MacNodeId b) { return static_cast<unsigned short>(a) < static_cast<unsigned short>(b); }
inline bool operator>(MacNodeId a, MacNodeId b) { return static_cast<unsigned short>(a) > static_cast<unsigned short>(b); }
inline bool operator<=(MacNodeId a, MacNodeId b) { return static_cast<unsigned short>(a) <= static_cast<unsigned short>(b); }
inline bool operator>=(MacNodeId a, MacNodeId b) { return static_cast<unsigned short>(a) >= static_cast<unsigned short>(b); }
inline MacNodeId operator+(MacNodeId a, unsigned int b) { return MacNodeId(static_cast<unsigned short>(a) + b); }
inline MacNodeId operator-(MacNodeId a, unsigned int b) { return MacNodeId(static_cast<unsigned short>(a) - b); }
inline MacNodeId operator-(unsigned int a, MacNodeId b) { return MacNodeId(a - static_cast<unsigned short>(b)); }
inline unsigned short operator-(MacNodeId a, MacNodeId b) { return static_cast<unsigned short>(a) - static_cast<unsigned short>(b); }

// parsimPack() needed fpr the "d" fingerprint ingredient
inline void doParsimPacking(omnetpp::cCommBuffer *buffer, MacNodeId d) {buffer->pack(num(d));}
inline void doParsimUnpacking(omnetpp::cCommBuffer *buffer, MacNodeId& d) {unsigned short tmp; buffer->unpack(tmp); d = MacNodeId(tmp);}

/// Node Id bounds
constexpr MacNodeId NODEID_NONE  = MacNodeId(0);
constexpr MacNodeId ENB_MIN_ID   = MacNodeId(1);
constexpr MacNodeId ENB_MAX_ID   = MacNodeId(1023);
constexpr MacNodeId BGUE_ID      = MacNodeId(1024);
constexpr MacNodeId UE_MIN_ID    = MacNodeId(1025);
constexpr MacNodeId NR_UE_MIN_ID = MacNodeId(2049);
constexpr MacNodeId BGUE_MIN_ID  = MacNodeId(4097);
constexpr MacNodeId UE_MAX_ID    = MacNodeId(32767);

/// Cell node ID. It is numerically equal to eNodeB MAC node ID.
typedef MacNodeId MacCellId;

/// X2 node ID. It is equal to the eNodeB MAC Cell ID
typedef MacNodeId X2NodeId;

/// Logical Connection Identifier
typedef unsigned short LogicalCid;

/// Connection Identifier: <MacNodeId,LogicalCid>
// MacCid is now a class with separate fields instead of a packed integer

/// Rank Indicator
typedef unsigned short Rank;

/// Channel Quality Indicator
typedef unsigned short Cqi;

/// Precoding Matrix Index
typedef unsigned short Pmi;

/// Transport Block Size
typedef unsigned short Tbs;

/// Logical band
typedef unsigned short Band;

/**
 *  Block allocation Map: # of Rbs per Band, per Remote.
 */
typedef std::map<Remote, std::map<Band, unsigned int>> RbMap;

/**
 * MAC Connection Identifier class that contains separate fields for
 * MacNodeId and LogicalCid instead of packing them into a single integer.
 * Can be used as std::map key and provides string representation.
 */
class MacCid
{
private:
    MacNodeId nodeId_;
    LogicalCid lcid_;

public:
    // Default constructor
    MacCid() : nodeId_(static_cast<MacNodeId>(0)), lcid_(0) {}

    // Constructor
    MacCid(MacNodeId nodeId, LogicalCid lcid) : nodeId_(nodeId), lcid_(lcid) {}

    // Getters
    MacNodeId getNodeId() const { return nodeId_; }
    LogicalCid getLcid() const { return lcid_; }
    unsigned int asPackedInt() const { return (num(nodeId_) << 16) | lcid_; }

    // Check if this is an empty/invalid MacCid (default constructed)
    bool isEmpty() const { return num(nodeId_) == 0 && lcid_ == 0; }

    // String representation
    std::string str() const { return "MacCid(nodeId=" + std::to_string(num(nodeId_)) + ", lcid=" + std::to_string(lcid_) + ")"; }

    // Comparison operators for std::map compatibility
    bool operator<(const MacCid& other) const { return asPackedInt() < other.asPackedInt(); }
    bool operator==(const MacCid& other) const  { return nodeId_ == other.nodeId_ && lcid_ == other.lcid_; }
    bool operator!=(const MacCid& other) const { return nodeId_ != other.nodeId_ || lcid_ != other.lcid_; }

    // Stream output operator
    friend std::ostream& operator<<(std::ostream& os, const MacCid& cid) { return os << cid.str(); }
};
// }}

/**
 * Struct generated from simu5g/common/LteCommon.msg:248 by opp_msgtool.
 */
struct RemoteUnitPhyData
{
    RemoteUnitPhyData();
    int txPower = 0;
    ::inet::Coord m;
};

// helpers for local use
void __doPacking(omnetpp::cCommBuffer *b, const RemoteUnitPhyData& a);
void __doUnpacking(omnetpp::cCommBuffer *b, RemoteUnitPhyData& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RemoteUnitPhyData& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RemoteUnitPhyData& obj) { __doUnpacking(b, obj); }

/**
 * Struct generated from simu5g/common/LteCommon.msg:254 by opp_msgtool.
 */
struct FeedbackRequest
{
    FeedbackRequest();
    bool request = false;
    FeedbackGeneratorType genType = static_cast<simu5g::FeedbackGeneratorType>(-1);
    FeedbackType type = static_cast<simu5g::FeedbackType>(-1);
    TxMode txMode = static_cast<simu5g::TxMode>(-1);
    bool dasAware = false;
    RbAllocationType rbAllocationType = static_cast<simu5g::RbAllocationType>(-1);
};

// helpers for local use
void __doPacking(omnetpp::cCommBuffer *b, const FeedbackRequest& a);
void __doUnpacking(omnetpp::cCommBuffer *b, FeedbackRequest& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const FeedbackRequest& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, FeedbackRequest& obj) { __doUnpacking(b, obj); }

// cplusplus {{
#include <inet/common/Units.h>
// }}


}  // namespace simu5g


namespace inet {

// cplusplus {{
using namespace units::values;
// }}


}  // namespace inet


namespace omnetpp {

inline any_ptr toAnyPtr(const simu5g::MacCid *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline simu5g::MacCid *fromAnyPtr(any_ptr ptr) { return ptr.get<simu5g::MacCid>(); }
inline any_ptr toAnyPtr(const simu5g::RemoteUnitPhyData *p) {return any_ptr(p);}
template<> inline simu5g::RemoteUnitPhyData *fromAnyPtr(any_ptr ptr) { return ptr.get<simu5g::RemoteUnitPhyData>(); }
inline any_ptr toAnyPtr(const simu5g::FeedbackRequest *p) {return any_ptr(p);}
template<> inline simu5g::FeedbackRequest *fromAnyPtr(any_ptr ptr) { return ptr.get<simu5g::FeedbackRequest>(); }
inline any_ptr toAnyPtr(const inet::GHz *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline inet::GHz *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::GHz>(); }

}  // namespace omnetpp

#endif // ifndef __SIMU5G_LTECOMMON_M_H

